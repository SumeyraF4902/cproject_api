Bu verileri temsil etmek için, bir POJO (Plain Old Java Object) sınıfı oluşturmanız gerekiyor. Her bir veri öğesi,
 bir nesne olarak temsil edilebilir ve bu nesne, POJO sınıfının özellikleri (property) olabilir.

Aşağıdaki POJO sınıfı örneği, bu verileri temsil edebilir:

java
Copy code
public class User {
    private int id;
    private String name;
    private int app_id;

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getApp_id() {
        return app_id;
    }

    public void setApp_id(int app_id) {
        this.app_id = app_id;
    }
}
Bu sınıf, "id", "name" ve "app_id" özelliklerine sahip bir "User" nesnesi oluşturur. Bu sınıfı kullanarak, verileri bir List<User>
koleksiyonunda depolayabilirsiniz.

Aşağıdaki kod, verileri JSON formatında bir String'den okur ve List<User> koleksiyonuna dönüştürür:

java
Copy code
ObjectMapper mapper = new ObjectMapper();
List<User> users = mapper.readValue(jsonString, new TypeReference<List<User>>(){});
Bu kod, Jackson kütüphanesini kullanır ve "jsonString" değişkeninde depolanan JSON verilerini,
List<User> koleksiyonuna dönüştürür.
"jsonString" değişkenini, yukarıdaki verilerle değiştirdiğinizde, bu kod POJO nesneleri oluşturacaktır.




lezzet haritası
peki bunların nasıl expected ve actual lerini doğrularız
Eğer bir test senaryosunda, bir fonksiyonun bu POJO nesneleriyle işlem yaptığını test etmek
 istiyorsanız, JUnit gibi bir
test çerçevesi kullanarak "expected" ve "actual" değerlerini doğrulayabilirsiniz.

Örneğin, bir test senaryosunda, yukarıdaki örnekteki POJO sınıfını kullanan bir fonksiyonun,
yukarıdaki örnekteki verileri okuduğunu
 ve List<User> koleksiyonuna doğru bir şekilde dönüştürdüğünü test etmek istiyoruz.

Bu senaryoyu JUnit kullanarak şu şekilde test edebiliriz:

java
Copy code
import org.junit.Test;
import static org.junit.Assert.assertEquals;
import java.util.List;

public class UserTest {

    @Test
    public void testJsonToUserList() throws Exception {
        String jsonString = "[{\"id\":17,\"name\":\"A3M_ADMIN\",\"app_id\":2},"
                + "{\"id\":23,\"name\":\"Accountant\",\"app_id\":2},"
                + "{\"id\":4,\"name\":\"APP_DOMAIN_MANAGER\",\"app_id\":2},"
                + "{\"id\":30,\"name\":\"Customer\",\"app_id\":2},"
                + "{\"id\":6,\"name\":\"Guest\",\"app_id\":2},"
                + "{\"id\":26,\"name\":\"Logistics Manager\",\"app_id\":2},"
                + "{\"id\":27,\"name\":\"Logistics Personnel\",\"app_id\":2},"
                + "{\"id\":21,\"name\":\"Purchase Manager\",\"app_id\":2},"
                + "{\"id\":22,\"name\":\"Purchase Personnel\",\"app_id\":2},"
                + "{\"id\":29,\"name\":\"Quality Controller\",\"app_id\":2},"
                + "{\"id\":28,\"name\":\"Quality Manager\",\"app_id\":2},"
                + "{\"id\":19,\"name\":\"Sales Manager\",\"app_id\":2},"
                + "{\"id\":20,\"name\":\"Sales Personnel\",\"app_id\":2},"
                + "{\"id\":18,\"name\":\"Store Manager\",\"app_id\":2},"
                + "{\"id\":24,\"name\":\"Warehouse Manager\",\"app_id\":2},"
                + "{\"id\":25,\"name\":\"Warehouse Personnel\",\"app_id\":2},"
                + "{\"id\":5,\"name\":\"Business Owner\",\"app_id\":2}]";

        ObjectMapper mapper = new ObjectMapper();
        List<User> actualUsers = mapper.readValue(jsonString, new TypeReference<List<User>>(){});

        assertEquals(17, actualUsers.get(0).getId());
        assertEquals("A3M_ADMIN", actualUsers.get(0).getName());
        assertEquals(2, actualUsers.get(0).getApp_id());

        // diğer User nesneleri için de aynı şekilde doğrulama yapabiliriz.
    }
}
Bu test senaryosunda, yukarıdaki örnekteki POJO sınıfını kullanarak "jsonString"
 değişkenindeki JSON verilerini List<User> koleksiyonuna dönüştürdük.
 Daha sonra, assertEquals() metodunu kullanarak, beklenen (expected) değerleri
 (17, "A3M_ADMIN", 2) ve gerçek (actual) değerleri (actualUsers.get(0).getId(), actualUsers.get(0)
 .getName(), actualUsers.get(0).getApp_id()) karşılaştırdık. Bö




lezzet haritası
peki for i döngüsüyle daha kısa karşılaştırma yapabilirmiyiz
Evet, tabii ki. Bir for döngüsü kullanarak expected ve actual listelerini tek tek karşılaştırabilirsiniz.
 Aşağıdaki örnek kodda, for döngüsü kullanarak expected ve actual listelerindeki öğeleri
  karşılaştıran bir test yazılmıştır:

java
Copy code
@Test
public void testUserRoles() {
    List<UserRole> expected = Arrays.asList(
            new UserRole(17, "A3M_ADMIN", 2),
            new UserRole(23, "Accountant", 2),
            new UserRole(4, "APP_DOMAIN_MANAGER", 2),
            new UserRole(30, "Customer", 2),
            new UserRole(6, "Guest", 2),
            new UserRole(26, "Logistics Manager", 2),
            new UserRole(27, "Logistics Personnel", 2),
            new UserRole(21, "Purchase Manager", 2),
            new UserRole(22, "Purchase Personnel", 2),
            new UserRole(29, "Quality Controller", 2),
            new UserRole(28, "Quality Manager", 2),
            new UserRole(19, "Sales Manager", 2),
            new UserRole(20, "Sales Personnel", 2),
            new UserRole(18, "Store Manager", 2),
            new UserRole(24, "Warehouse Manager", 2),
            new UserRole(25, "Warehouse Personnel", 2),
            new UserRole(5, "Business Owner", 2)
    );

    List<UserRole> actual = getUserRolesFromDatabase();

    assertEquals(expected.size(), actual.size());

    for (int i = 0; i < expected.size(); i++) {
        assertEquals(expected.get(i), actual.get(i));
    }
}
Bu örnekte expected ve actual listelerinin öğeleri tek tek assertEquals ile karşılaştırılmaktadır. Bu yöntemle de doğrulama işlemi gerçekleştirilebilir.
 Ancak assertArrayEquals yöntemi kadar kolay ve okunaklı olmayabilir.